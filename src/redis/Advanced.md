下面先梳理三种模式的**优势与区别**，再给出在**局域网环境**下可直接套用的部署示例（假设局域网网段为 `192.168.1.0/24`，操作系统 Linux，已安装 Redis 7.x）。

---

## 1️⃣ 三种模式概览

| 模式                    | 结构                | 优势                    | 主要不足           | 适用场景           |
| --------------------- | ----------------- | --------------------- | -------------- | -------------- |
| **副本集 (Replication)** | 1 主 + N 从         | 简单、读写分离、从节点可做冷备       | 主宕机需人工切换，写性能单点 | 读多写少、可接受手动运维   |
| **哨兵 (Sentinel)**     | 1 主 + N 从 + 3+ 哨兵 | 自动故障转移、高可用、客户端可自动发现新主 | 仍是单主写，容量受限     | 中小规模，要求自动容灾    |
| **集群 (Cluster)**      | 多主多从，16384 槽      | 水平分片、读写都可扩展、去中心化      | 部署复杂，不支持跨槽事务   | 大数据量、高 QPS、高可用 |

---

## 2️⃣ 局域网部署示例

以下 IP 仅示例，请根据你的局域网实际调整。

### A. 副本集（简单主从）

**目标**：`192.168.1.10` 为主，`192.168.1.11` 为从。

1. **主节点** (`192.168.1.10`)
   `/etc/redis/redis.conf`

   ```conf
   bind 0.0.0.0
   port 6379
   protected-mode no
   ```

   启动：

   ```bash
   redis-server /etc/redis/redis.conf
   ```

2. **从节点** (`192.168.1.11`)
   `/etc/redis/redis.conf`

   ```conf
   bind 0.0.0.0
   port 6379
   replicaof 192.168.1.10 6379
   ```

   启动：

   ```bash
   redis-server /etc/redis/redis.conf
   ```

> 客户端读写主库，读压力大时可读从库。主挂了需手工执行 `replicaof no one` 将从提升为主。

---

### B. 哨兵模式

**目标**：主从与上面一致，外加 3 个 Sentinel 节点（可与 Redis 节点同机不同端口）。

* 节点示例：

  * Redis 主：`192.168.1.10:6379`
  * Redis 从：`192.168.1.11:6379`
  * Sentinel：`192.168.1.10:26379`, `192.168.1.11:26379`, `192.168.1.12:26379`

**Sentinel 配置（每个哨兵类似）：**
`/etc/redis/sentinel.conf`

```conf
port 26379
sentinel monitor mymaster 192.168.1.10 6379 2
sentinel down-after-milliseconds mymaster 5000
sentinel failover-timeout mymaster 10000
sentinel auth-pass mymaster <password-if-any>
```

启动：

```bash
redis-sentinel /etc/redis/sentinel.conf
```

* 至少 3 个哨兵，`quorum` 设置为 2。
* 主节点挂掉后，哨兵会自动把从节点提升为主，并通知客户端新主地址。

---

### C. 集群模式

**目标**：6 节点，3 主 3 从（最小生产建议）。

* 节点：

  ```
  192.168.1.21 7000
  192.168.1.22 7000
  192.168.1.23 7000
  192.168.1.24 7000
  192.168.1.25 7000
  192.168.1.26 7000
  ```

**每个节点配置示例** `/etc/redis/7000.conf`

```conf
port 7000
cluster-enabled yes
cluster-config-file nodes-7000.conf
cluster-node-timeout 5000
appendonly yes
bind 0.0.0.0
```

启动所有节点：

```bash
redis-server /etc/redis/7000.conf
```

创建集群：

```bash
redis-cli --cluster create \
192.168.1.21:7000 192.168.1.22:7000 192.168.1.23:7000 \
192.168.1.24:7000 192.168.1.25:7000 192.168.1.26:7000 \
--cluster-replicas 1
```

* `--cluster-replicas 1` 表示每个主节点一个从节点。
* 客户端连接任意节点即可访问整个集群，数据会按 16384 槽自动分片。

---

## 3️⃣ 选择建议

| 需求              | 推荐       |
| --------------- | -------- |
| 读多写少，人工切换可接受    | **副本集**  |
| 高可用、写量一般、运维中等   | **哨兵模式** |
| 数据量大、写压力高、需水平扩展 | **集群模式** |

---

### 🔑 总结

* **副本集**：部署最简单，仅读扩展。
* **哨兵模式**：在副本集上加**自动故障转移**，是中小企业高可用的常见方案。
* **集群模式**：真正的**多主分片 + 高可用**，适合海量数据和高并发。
  以上局域网实例可直接按需修改 IP 和路径部署，用于测试或小规模生产环境。
