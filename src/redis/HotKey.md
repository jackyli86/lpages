在 Redis 中，**Hot Key（热点 Key）** 是指**访问频率远高于其他键**的 key。
它与“大 Key”不同：**大 Key**关注数据体积，而**热 Key**关注**访问量分布**。
如果一个 key 在短时间内被大量并发请求，就可能导致 Redis 成为单点瓶颈。

---

## 1️⃣ 典型场景

* **秒杀/抢购**：商品库存 key 被海量请求同时读取或修改。
* **热门榜单**：某个排行榜数据被频繁查询。
* **热点缓存**：某条热门新闻或视频详情被持续刷取。

---

## 2️⃣ 风险与影响

1. **单 Key 读写压力**：Redis 单线程处理，所有请求都需串行执行，对单 Key 的高并发可能占用 CPU。
2. **网络带宽**：某个 key 响应过大或请求过多导致出口带宽耗尽。
3. **主从复制延迟**：主节点热 Key 高并发写入导致从节点同步压力大。
4. **本地缓存失效风暴**：缓存击穿后，大量请求同时回源数据库。

---

## 3️⃣ 热点 Key 发现方式

### 内置命令

* **Redis 4.0+**

  ```bash
  redis-cli --hotkeys
  ```

  * 需启用 `redis.conf`：

    ```
    hotkeys-sampling 1
    ```
  * 输出每个采样到的 Key 的访问频次估算。

### MONITOR

```bash
redis-cli monitor | grep <pattern>
```

* 直接打印所有操作，可实时观察，但在生产环境代价大。

### INFO 命令

```bash
redis-cli info keyspace
```

* 只能看每个数据库的键总数和过期数，无法精确定位。

### 第三方工具

* **redis-exporter + Prometheus + Grafana**：统计每 Key QPS。
* **proxy 层日志**（如 Twemproxy、Codis）也能统计命中率。

---

## 4️⃣ 常见缓解措施

1. **本地缓存**

   * 在应用层引入 **本地内存缓存**（如 Guava Cache、Caffeine、Nginx 缓存）拦截大部分请求。
   * 例如热点数据加一层 30 秒短 TTL 的 JVM 缓存。

2. **读写分离 / 分片**

   * 使用 Redis Cluster 或多实例分片，将 key 的不同部分路由到不同节点。
   * 对单个超热 key 可采用 **key 前缀+随机后缀** 的方式拆分，如 `hotkey:{id}:{1..n}`。

3. **多副本+负载均衡**

   * 读操作可使用读副本（从节点），在客户端做读流量分摊。

4. **结果预计算 & 异步更新**

   * 对实时聚合、排行榜等热点数据，提前生成结果，异步定时刷新。

5. **防止缓存击穿**

   * 对可能空值的 key 加空值缓存（短 TTL），避免 DB 被打爆。

---

## 5️⃣ 与“大 Key”区别

| 特性   | 大 Key          | 热 Key           |
| ---- | -------------- | --------------- |
| 关注点  | 数据体积过大         | 访问频率过高          |
| 主要风险 | 删除/传输阻塞、内存浪费   | CPU 单线程瓶颈、带宽、击穿 |
| 优化思路 | 拆分存储、分页读取、异步删除 | 本地缓存、分片、多副本、限流  |

---

### ✅ 总结

* **Hot Key** = “访问最频繁的键”，会造成 CPU、带宽、复制延迟等压力。
* 发现：`redis-cli --hotkeys`、Monitor、代理日志、Prometheus。
* 缓解：**本地缓存、分片拆分、读写分离、异步更新、限流**。
  在高并发场景下，应配合系统架构（CDN、应用缓存、数据库）一起设计，避免单 Key 成为性能瓶颈。
